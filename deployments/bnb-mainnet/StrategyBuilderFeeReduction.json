{
  "address": "0x706C36057D7363a9313A545280a6CA310e0c1A47",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_lock",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_router",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_factory",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "AlreadyTokenActive",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "optionType",
          "type": "uint16"
        }
      ],
      "name": "InvalidOptionType",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NoTokenActive",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotAllowed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OutOfFunds",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "bits",
          "type": "uint8"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "SafeCastOverflowedUintDowncast",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "rarity",
          "type": "uint8"
        }
      ],
      "name": "Deposit",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "Withdraw",
      "type": "event"
    },
    {
      "stateMutability": "payable",
      "type": "fallback"
    },
    {
      "inputs": [],
      "name": "PERCENTAGE_DIVISOR",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "wallet",
          "type": "address"
        }
      ],
      "name": "_resolveVaultOwner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint8",
          "name": "rarity",
          "type": "uint8"
        }
      ],
      "name": "activateTokenForUser",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "factory",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "wallet",
          "type": "address"
        }
      ],
      "name": "getFeeReduction",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "lock",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "router",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "strategyVaultInterfaceId",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "userTokenInfos",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint8",
          "name": "rarity",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint128",
          "name": "customGasLimit",
          "type": "uint128"
        }
      ],
      "name": "withdrawToken",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "transactionHash": "0x9468385b48c3ae146d21abc40b289cf2fa0a5e2ca4668b9a6715c43ee24edc56",
  "receipt": {
    "to": null,
    "from": "0xd4Fa4ee93D7D27c1c4Be36bfBa67183dD4320123",
    "contractAddress": "0x706C36057D7363a9313A545280a6CA310e0c1A47",
    "transactionIndex": 56,
    "gasUsed": "855765",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x171b3bdbf1c9255c25247ca46b89d4bd2715288a93b5112ee27505a8cc3c2dfc",
    "transactionHash": "0x9468385b48c3ae146d21abc40b289cf2fa0a5e2ca4668b9a6715c43ee24edc56",
    "logs": [],
    "blockNumber": 80387588,
    "cumulativeGasUsed": "8398514",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x75B9a6759bF03Deed169792c86111Dd7037f97EB",
    "0x9294e9D2C8Da3a2F500A8772c8Bec08d95516e80",
    "0xc245f625b416F8Da96dD0Bfc3d190cd9FeC262A3"
  ],
  "numDeployments": 2,
  "solcInputHash": "9855c2804d2e33a3e83fdbdef732e2d1",
  "metadata": "{\"compiler\":{\"version\":\"0.8.22+commit.4fc1097e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lock\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyTokenActive\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"optionType\",\"type\":\"uint16\"}],\"name\":\"InvalidOptionType\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoTokenActive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OutOfFunds\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"bits\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SafeCastOverflowedUintDowncast\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"rarity\",\"type\":\"uint8\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"PERCENTAGE_DIVISOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"_resolveVaultOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"rarity\",\"type\":\"uint8\"}],\"name\":\"activateTokenForUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getFeeReduction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lock\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strategyVaultInterfaceId\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userTokenInfos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"rarity\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"customGasLimit\",\"type\":\"uint128\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"author\":\"3Blocks UG\",\"details\":\"This contract resolves the effective user address in case the provided wallet is a StrategyVault contract by: - Checking ERC165 supportsInterface for IStrategyVault - Resolving the underlying owner() if applicable The final fee reduction is defined as the maximum of: - The reduction derived from the user's lock tier - The reduction derived from the deposited NFT rarity Fee reductions are expressed in basis points (bps), where 10_000 = 100%. This contract is designed to be read-only for fee logic, except for explicit NFT deposit/withdrawal by users.\",\"errors\":{\"SafeCastOverflowedUintDowncast(uint8,uint256)\":[{\"details\":\"Value doesn't fit in an uint of `bits` size.\"}]},\"events\":{\"Deposit(address,uint256,uint8)\":{\"params\":{\"account\":\"The user receiving activation\",\"rarity\":\"The rarity of the deposited NFT\",\"tokenId\":\"The deposited NFT tokenId\"}},\"Withdraw(address,uint256)\":{\"params\":{\"account\":\"The withdrawing user\",\"tokenId\":\"The withdrawn tokenId\"}}},\"kind\":\"dev\",\"methods\":{\"_resolveVaultOwner(address)\":{\"details\":\"If the wallet is an EOA, it is returned directly. If the wallet is a contract, this function attempts to: 1. Detect if it supports the IStrategyVault interface via ERC165. 2. If so, attempt to resolve the underlying owner() address. If any step fails (revert, invalid return data, zero owner), the original wallet address is used as a safe fallback. This ensures robustness against: - Non-compliant contracts - Malicious or reverting implementations - Unexpected ABI behavior\",\"params\":{\"wallet\":\"The wallet or contract address to resolve.\"},\"returns\":{\"_0\":\"resolved The resolved owner or original wallet address.\"}},\"activateTokenForUser(address,uint256,uint8)\":{\"details\":\"Router-only function, called when an NFT activation message arrives cross-chain Requirements: - Caller must be router - User must not already have an active token Emits {Deposit}\",\"params\":{\"rarity\":\"The rarity classification of the NFT\",\"tokenId\":\"The activated NFT tokenId\",\"user\":\"The user receiving the activation\"}},\"getFeeReduction(address)\":{\"details\":\"If the wallet is a StrategyVault, the underlying owner is resolved and used for fee calculation. The returned reduction is the maximum of: - Lock-tier based fee reduction - NFT-rarity based fee reduction If neither applies, returns 0.\",\"params\":{\"wallet\":\"The wallet or StrategyVault address to query.\"},\"returns\":{\"_0\":\"reduction The fee reduction in basis points (bps).\"}},\"withdrawToken(uint128)\":{\"details\":\"Resets the user's deposited token state and transfers the token back to the user. Requirements: - The caller must have a token deposited. Emits a {Withdraw} event.\"}},\"stateVariables\":{\"lock\":{\"details\":\"Used to resolve the user's lock tier for fee reduction.\"},\"userTokenInfos\":{\"details\":\"Each user may deposit at most one NFT at a time. A value of 0 indicates no NFT deposited.\"}},\"title\":\"FeeReduction\",\"version\":1},\"userdoc\":{\"errors\":{\"AlreadyTokenActive()\":[{\"notice\":\"User already has an active deposited token\"}],\"NoTokenActive()\":[{\"notice\":\"User has no active token deposited\"}],\"NotAllowed()\":[{\"notice\":\"Caller is not allowed (router-only)\"}],\"OutOfFunds()\":[{\"notice\":\"Contract has insufficient native funds to send cross-chain message\"}]},\"events\":{\"Deposit(address,uint256,uint8)\":{\"notice\":\"Emitted when a token is deposited for a user\"},\"Withdraw(address,uint256)\":{\"notice\":\"Emitted when a user withdraws their deposited token\"}},\"kind\":\"user\",\"methods\":{\"PERCENTAGE_DIVISOR()\":{\"notice\":\"Divisor for percentage calculations (10000 = 100%).\"},\"_resolveVaultOwner(address)\":{\"notice\":\"Resolves the effective user address for fee calculations.\"},\"activateTokenForUser(address,uint256,uint8)\":{\"notice\":\"Deposits a token activation for a user\"},\"getFeeReduction(address)\":{\"notice\":\"Returns the effective fee reduction for a given wallet.\"},\"lock()\":{\"notice\":\"Address of the Tiered Token Locker contract.\"},\"router()\":{\"notice\":\"Returns the router allowed to deposit tokens\"},\"userTokenInfos(address)\":{\"notice\":\"Mapping of user address to deposited NFT tokenId.\"},\"withdrawToken(uint128)\":{\"notice\":\"Withdraws the previously deposited token.\"}},\"notice\":\"Provides a unified fee reduction mechanism based on: 1) Token lock tiers 2) Deposited NFT rarity\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/StrategyBuilderFeeReduction.sol\":\"StrategyBuilderFeeReduction\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@layerzerolabs/lz-evm-messagelib-v2/contracts/libs/ExecutorOptions.sol\":{\"content\":\"// SPDX-License-Identifier: LZBL-1.2\\n\\npragma solidity ^0.8.20;\\n\\nimport \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/CalldataBytesLib.sol\\\";\\n\\nlibrary ExecutorOptions {\\n    using CalldataBytesLib for bytes;\\n\\n    uint8 internal constant WORKER_ID = 1;\\n\\n    uint8 internal constant OPTION_TYPE_LZRECEIVE = 1;\\n    uint8 internal constant OPTION_TYPE_NATIVE_DROP = 2;\\n    uint8 internal constant OPTION_TYPE_LZCOMPOSE = 3;\\n    uint8 internal constant OPTION_TYPE_ORDERED_EXECUTION = 4;\\n    uint8 internal constant OPTION_TYPE_LZREAD = 5;\\n\\n    error Executor_InvalidLzReceiveOption();\\n    error Executor_InvalidNativeDropOption();\\n    error Executor_InvalidLzComposeOption();\\n    error Executor_InvalidLzReadOption();\\n\\n    /// @dev decode the next executor option from the options starting from the specified cursor\\n    /// @param _options [executor_id][executor_option][executor_id][executor_option]...\\n    ///        executor_option = [option_size][option_type][option]\\n    ///        option_size = len(option_type) + len(option)\\n    ///        executor_id: uint8, option_size: uint16, option_type: uint8, option: bytes\\n    /// @param _cursor the cursor to start decoding from\\n    /// @return optionType the type of the option\\n    /// @return option the option of the executor\\n    /// @return cursor the cursor to start decoding the next executor option\\n    function nextExecutorOption(\\n        bytes calldata _options,\\n        uint256 _cursor\\n    ) internal pure returns (uint8 optionType, bytes calldata option, uint256 cursor) {\\n        unchecked {\\n            // skip worker id\\n            cursor = _cursor + 1;\\n\\n            // read option size\\n            uint16 size = _options.toU16(cursor);\\n            cursor += 2;\\n\\n            // read option type\\n            optionType = _options.toU8(cursor);\\n\\n            // startCursor and endCursor are used to slice the option from _options\\n            uint256 startCursor = cursor + 1; // skip option type\\n            uint256 endCursor = cursor + size;\\n            option = _options[startCursor:endCursor];\\n            cursor += size;\\n        }\\n    }\\n\\n    function decodeLzReceiveOption(bytes calldata _option) internal pure returns (uint128 gas, uint128 value) {\\n        if (_option.length != 16 && _option.length != 32) revert Executor_InvalidLzReceiveOption();\\n        gas = _option.toU128(0);\\n        value = _option.length == 32 ? _option.toU128(16) : 0;\\n    }\\n\\n    function decodeNativeDropOption(bytes calldata _option) internal pure returns (uint128 amount, bytes32 receiver) {\\n        if (_option.length != 48) revert Executor_InvalidNativeDropOption();\\n        amount = _option.toU128(0);\\n        receiver = _option.toB32(16);\\n    }\\n\\n    function decodeLzComposeOption(\\n        bytes calldata _option\\n    ) internal pure returns (uint16 index, uint128 gas, uint128 value) {\\n        if (_option.length != 18 && _option.length != 34) revert Executor_InvalidLzComposeOption();\\n        index = _option.toU16(0);\\n        gas = _option.toU128(2);\\n        value = _option.length == 34 ? _option.toU128(18) : 0;\\n    }\\n\\n    function decodeLzReadOption(\\n        bytes calldata _option\\n    ) internal pure returns (uint128 gas, uint32 calldataSize, uint128 value) {\\n        if (_option.length != 20 && _option.length != 36) revert Executor_InvalidLzReadOption();\\n        gas = _option.toU128(0);\\n        calldataSize = _option.toU32(16);\\n        value = _option.length == 36 ? _option.toU128(20) : 0;\\n    }\\n\\n    function encodeLzReceiveOption(uint128 _gas, uint128 _value) internal pure returns (bytes memory) {\\n        return _value == 0 ? abi.encodePacked(_gas) : abi.encodePacked(_gas, _value);\\n    }\\n\\n    function encodeNativeDropOption(uint128 _amount, bytes32 _receiver) internal pure returns (bytes memory) {\\n        return abi.encodePacked(_amount, _receiver);\\n    }\\n\\n    function encodeLzComposeOption(uint16 _index, uint128 _gas, uint128 _value) internal pure returns (bytes memory) {\\n        return _value == 0 ? abi.encodePacked(_index, _gas) : abi.encodePacked(_index, _gas, _value);\\n    }\\n\\n    function encodeLzReadOption(\\n        uint128 _gas,\\n        uint32 _calldataSize,\\n        uint128 _value\\n    ) internal pure returns (bytes memory) {\\n        return _value == 0 ? abi.encodePacked(_gas, _calldataSize) : abi.encodePacked(_gas, _calldataSize, _value);\\n    }\\n}\\n\",\"keccak256\":\"0x441b723f2f597be2ec2bb361fcf3f11852c23534db1cfa7d2ffff7e61d228e3c\",\"license\":\"LZBL-1.2\"},\"@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/libs/DVNOptions.sol\":{\"content\":\"// SPDX-License-Identifier: LZBL-1.2\\n\\npragma solidity ^0.8.20;\\n\\nimport { BytesLib } from \\\"solidity-bytes-utils/contracts/BytesLib.sol\\\";\\n\\nimport { BitMap256 } from \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/BitMaps.sol\\\";\\nimport { CalldataBytesLib } from \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/CalldataBytesLib.sol\\\";\\n\\nlibrary DVNOptions {\\n    using CalldataBytesLib for bytes;\\n    using BytesLib for bytes;\\n\\n    uint8 internal constant WORKER_ID = 2;\\n    uint8 internal constant OPTION_TYPE_PRECRIME = 1;\\n\\n    error DVN_InvalidDVNIdx();\\n    error DVN_InvalidDVNOptions(uint256 cursor);\\n\\n    /// @dev group dvn options by its idx\\n    /// @param _options [dvn_id][dvn_option][dvn_id][dvn_option]...\\n    ///        dvn_option = [option_size][dvn_idx][option_type][option]\\n    ///        option_size = len(dvn_idx) + len(option_type) + len(option)\\n    ///        dvn_id: uint8, dvn_idx: uint8, option_size: uint16, option_type: uint8, option: bytes\\n    /// @return dvnOptions the grouped options, still share the same format of _options\\n    /// @return dvnIndices the dvn indices\\n    function groupDVNOptionsByIdx(\\n        bytes memory _options\\n    ) internal pure returns (bytes[] memory dvnOptions, uint8[] memory dvnIndices) {\\n        if (_options.length == 0) return (dvnOptions, dvnIndices);\\n\\n        uint8 numDVNs = getNumDVNs(_options);\\n\\n        // if there is only 1 dvn, we can just return the whole options\\n        if (numDVNs == 1) {\\n            dvnOptions = new bytes[](1);\\n            dvnOptions[0] = _options;\\n\\n            dvnIndices = new uint8[](1);\\n            dvnIndices[0] = _options.toUint8(3); // dvn idx\\n            return (dvnOptions, dvnIndices);\\n        }\\n\\n        // otherwise, we need to group the options by dvn_idx\\n        dvnIndices = new uint8[](numDVNs);\\n        dvnOptions = new bytes[](numDVNs);\\n        unchecked {\\n            uint256 cursor = 0;\\n            uint256 start = 0;\\n            uint8 lastDVNIdx = 255; // 255 is an invalid dvn_idx\\n\\n            while (cursor < _options.length) {\\n                ++cursor; // skip worker_id\\n\\n                // optionLength asserted in getNumDVNs (skip check)\\n                uint16 optionLength = _options.toUint16(cursor);\\n                cursor += 2;\\n\\n                // dvnIdx asserted in getNumDVNs (skip check)\\n                uint8 dvnIdx = _options.toUint8(cursor);\\n\\n                // dvnIdx must equal to the lastDVNIdx for the first option\\n                // so it is always skipped in the first option\\n                // this operation slices out options whenever the scan finds a different lastDVNIdx\\n                if (lastDVNIdx == 255) {\\n                    lastDVNIdx = dvnIdx;\\n                } else if (dvnIdx != lastDVNIdx) {\\n                    uint256 len = cursor - start - 3; // 3 is for worker_id and option_length\\n                    bytes memory opt = _options.slice(start, len);\\n                    _insertDVNOptions(dvnOptions, dvnIndices, lastDVNIdx, opt);\\n\\n                    // reset the start and lastDVNIdx\\n                    start += len;\\n                    lastDVNIdx = dvnIdx;\\n                }\\n\\n                cursor += optionLength;\\n            }\\n\\n            // skip check the cursor here because the cursor is asserted in getNumDVNs\\n            // if we have reached the end of the options, we need to process the last dvn\\n            uint256 size = cursor - start;\\n            bytes memory op = _options.slice(start, size);\\n            _insertDVNOptions(dvnOptions, dvnIndices, lastDVNIdx, op);\\n\\n            // revert dvnIndices to start from 0\\n            for (uint8 i = 0; i < numDVNs; ++i) {\\n                --dvnIndices[i];\\n            }\\n        }\\n    }\\n\\n    function _insertDVNOptions(\\n        bytes[] memory _dvnOptions,\\n        uint8[] memory _dvnIndices,\\n        uint8 _dvnIdx,\\n        bytes memory _newOptions\\n    ) internal pure {\\n        // dvnIdx starts from 0 but default value of dvnIndices is 0,\\n        // so we tell if the slot is empty by adding 1 to dvnIdx\\n        if (_dvnIdx == 255) revert DVN_InvalidDVNIdx();\\n        uint8 dvnIdxAdj = _dvnIdx + 1;\\n\\n        for (uint256 j = 0; j < _dvnIndices.length; ++j) {\\n            uint8 index = _dvnIndices[j];\\n            if (dvnIdxAdj == index) {\\n                _dvnOptions[j] = abi.encodePacked(_dvnOptions[j], _newOptions);\\n                break;\\n            } else if (index == 0) {\\n                // empty slot, that means it is the first time we see this dvn\\n                _dvnIndices[j] = dvnIdxAdj;\\n                _dvnOptions[j] = _newOptions;\\n                break;\\n            }\\n        }\\n    }\\n\\n    /// @dev get the number of unique dvns\\n    /// @param _options the format is the same as groupDVNOptionsByIdx\\n    function getNumDVNs(bytes memory _options) internal pure returns (uint8 numDVNs) {\\n        uint256 cursor = 0;\\n        BitMap256 bitmap;\\n\\n        // find number of unique dvn_idx\\n        unchecked {\\n            while (cursor < _options.length) {\\n                ++cursor; // skip worker_id\\n\\n                uint16 optionLength = _options.toUint16(cursor);\\n                cursor += 2;\\n                if (optionLength < 2) revert DVN_InvalidDVNOptions(cursor); // at least 1 byte for dvn_idx and 1 byte for option_type\\n\\n                uint8 dvnIdx = _options.toUint8(cursor);\\n\\n                // if dvnIdx is not set, increment numDVNs\\n                // max num of dvns is 255, 255 is an invalid dvn_idx\\n                // The order of the dvnIdx is not required to be sequential, as enforcing the order may weaken\\n                // the composability of the options. e.g. if we refrain from enforcing the order, an OApp that has\\n                // already enforced certain options can append additional options to the end of the enforced\\n                // ones without restrictions.\\n                if (dvnIdx == 255) revert DVN_InvalidDVNIdx();\\n                if (!bitmap.get(dvnIdx)) {\\n                    ++numDVNs;\\n                    bitmap = bitmap.set(dvnIdx);\\n                }\\n\\n                cursor += optionLength;\\n            }\\n        }\\n        if (cursor != _options.length) revert DVN_InvalidDVNOptions(cursor);\\n    }\\n\\n    /// @dev decode the next dvn option from _options starting from the specified cursor\\n    /// @param _options the format is the same as groupDVNOptionsByIdx\\n    /// @param _cursor the cursor to start decoding\\n    /// @return optionType the type of the option\\n    /// @return option the option\\n    /// @return cursor the cursor to start decoding the next option\\n    function nextDVNOption(\\n        bytes calldata _options,\\n        uint256 _cursor\\n    ) internal pure returns (uint8 optionType, bytes calldata option, uint256 cursor) {\\n        unchecked {\\n            // skip worker id\\n            cursor = _cursor + 1;\\n\\n            // read option size\\n            uint16 size = _options.toU16(cursor);\\n            cursor += 2;\\n\\n            // read option type\\n            optionType = _options.toU8(cursor + 1); // skip dvn_idx\\n\\n            // startCursor and endCursor are used to slice the option from _options\\n            uint256 startCursor = cursor + 2; // skip option type and dvn_idx\\n            uint256 endCursor = cursor + size;\\n            option = _options[startCursor:endCursor];\\n            cursor += size;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2beee03cdf59a9bc72e94d08b69cb2e908725f4ceabb48651494938100e21e35\",\"license\":\"LZBL-1.2\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/CalldataBytesLib.sol\":{\"content\":\"// SPDX-License-Identifier: LZBL-1.2\\n\\npragma solidity ^0.8.20;\\n\\nlibrary CalldataBytesLib {\\n    function toU8(bytes calldata _bytes, uint256 _start) internal pure returns (uint8) {\\n        return uint8(_bytes[_start]);\\n    }\\n\\n    function toU16(bytes calldata _bytes, uint256 _start) internal pure returns (uint16) {\\n        unchecked {\\n            uint256 end = _start + 2;\\n            return uint16(bytes2(_bytes[_start:end]));\\n        }\\n    }\\n\\n    function toU32(bytes calldata _bytes, uint256 _start) internal pure returns (uint32) {\\n        unchecked {\\n            uint256 end = _start + 4;\\n            return uint32(bytes4(_bytes[_start:end]));\\n        }\\n    }\\n\\n    function toU64(bytes calldata _bytes, uint256 _start) internal pure returns (uint64) {\\n        unchecked {\\n            uint256 end = _start + 8;\\n            return uint64(bytes8(_bytes[_start:end]));\\n        }\\n    }\\n\\n    function toU128(bytes calldata _bytes, uint256 _start) internal pure returns (uint128) {\\n        unchecked {\\n            uint256 end = _start + 16;\\n            return uint128(bytes16(_bytes[_start:end]));\\n        }\\n    }\\n\\n    function toU256(bytes calldata _bytes, uint256 _start) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 end = _start + 32;\\n            return uint256(bytes32(_bytes[_start:end]));\\n        }\\n    }\\n\\n    function toAddr(bytes calldata _bytes, uint256 _start) internal pure returns (address) {\\n        unchecked {\\n            uint256 end = _start + 20;\\n            return address(bytes20(_bytes[_start:end]));\\n        }\\n    }\\n\\n    function toB32(bytes calldata _bytes, uint256 _start) internal pure returns (bytes32) {\\n        unchecked {\\n            uint256 end = _start + 32;\\n            return bytes32(_bytes[_start:end]);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5c0db161cef6603c3b256d4220f489419e7478ef775e52a80056654129c61875\",\"license\":\"LZBL-1.2\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/BitMaps.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n// modified from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/BitMaps.sol\\npragma solidity ^0.8.20;\\n\\ntype BitMap256 is uint256;\\n\\nusing BitMaps for BitMap256 global;\\n\\nlibrary BitMaps {\\n    /**\\n     * @dev Returns whether the bit at `index` is set.\\n     */\\n    function get(BitMap256 bitmap, uint8 index) internal pure returns (bool) {\\n        uint256 mask = 1 << index;\\n        return BitMap256.unwrap(bitmap) & mask != 0;\\n    }\\n\\n    /**\\n     * @dev Sets the bit at `index`.\\n     */\\n    function set(BitMap256 bitmap, uint8 index) internal pure returns (BitMap256) {\\n        uint256 mask = 1 << index;\\n        return BitMap256.wrap(BitMap256.unwrap(bitmap) | mask);\\n    }\\n}\\n\",\"keccak256\":\"0xaad3c72ef43480d2253fd48b394e8fb7286d009991d2bc4e61be58ce48ac5ee9\",\"license\":\"MIT\"},\"@layerzerolabs/oapp-evm/contracts/oapp/libs/OptionsBuilder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { BytesLib } from \\\"solidity-bytes-utils/contracts/BytesLib.sol\\\";\\nimport { SafeCast } from \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\n\\nimport { ExecutorOptions } from \\\"@layerzerolabs/lz-evm-messagelib-v2/contracts/libs/ExecutorOptions.sol\\\";\\nimport { DVNOptions } from \\\"@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/libs/DVNOptions.sol\\\";\\n\\n/**\\n * @title OptionsBuilder\\n * @dev Library for building and encoding various message options.\\n */\\nlibrary OptionsBuilder {\\n    using SafeCast for uint256;\\n    using BytesLib for bytes;\\n\\n    // Constants for options types\\n    uint16 internal constant TYPE_1 = 1; // legacy options type 1\\n    uint16 internal constant TYPE_2 = 2; // legacy options type 2\\n    uint16 internal constant TYPE_3 = 3;\\n\\n    // Custom error message\\n    error InvalidSize(uint256 max, uint256 actual);\\n    error InvalidOptionType(uint16 optionType);\\n\\n    // Modifier to ensure only options of type 3 are used\\n    modifier onlyType3(bytes memory _options) {\\n        if (_options.toUint16(0) != TYPE_3) revert InvalidOptionType(_options.toUint16(0));\\n        _;\\n    }\\n\\n    /**\\n     * @dev Creates a new options container with type 3.\\n     * @return options The newly created options container.\\n     */\\n    function newOptions() internal pure returns (bytes memory) {\\n        return abi.encodePacked(TYPE_3);\\n    }\\n\\n    /**\\n     * @dev Adds an executor LZ receive option to the existing options.\\n     * @param _options The existing options container.\\n     * @param _gas The gasLimit used on the lzReceive() function in the OApp.\\n     * @param _value The msg.value passed to the lzReceive() function in the OApp.\\n     * @return options The updated options container.\\n     *\\n     * @dev When multiples of this option are added, they are summed by the executor\\n     * eg. if (_gas: 200k, and _value: 1 ether) AND (_gas: 100k, _value: 0.5 ether) are sent in an option to the LayerZeroEndpoint,\\n     * that becomes (300k, 1.5 ether) when the message is executed on the remote lzReceive() function.\\n     */\\n    function addExecutorLzReceiveOption(\\n        bytes memory _options,\\n        uint128 _gas,\\n        uint128 _value\\n    ) internal pure onlyType3(_options) returns (bytes memory) {\\n        bytes memory option = ExecutorOptions.encodeLzReceiveOption(_gas, _value);\\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_LZRECEIVE, option);\\n    }\\n\\n    /**\\n     * @dev Adds an executor native drop option to the existing options.\\n     * @param _options The existing options container.\\n     * @param _amount The amount for the native value that is airdropped to the 'receiver'.\\n     * @param _receiver The receiver address for the native drop option.\\n     * @return options The updated options container.\\n     *\\n     * @dev When multiples of this option are added, they are summed by the executor on the remote chain.\\n     */\\n    function addExecutorNativeDropOption(\\n        bytes memory _options,\\n        uint128 _amount,\\n        bytes32 _receiver\\n    ) internal pure onlyType3(_options) returns (bytes memory) {\\n        bytes memory option = ExecutorOptions.encodeNativeDropOption(_amount, _receiver);\\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_NATIVE_DROP, option);\\n    }\\n\\n    // /**\\n    //  * @dev Adds an executor native drop option to the existing options.\\n    //  * @param _options The existing options container.\\n    //  * @param _amount The amount for the native value that is airdropped to the 'receiver'.\\n    //  * @param _receiver The receiver address for the native drop option.\\n    //  * @return options The updated options container.\\n    //  *\\n    //  * @dev When multiples of this option are added, they are summed by the executor on the remote chain.\\n    //  */\\n    function addExecutorLzReadOption(\\n        bytes memory _options,\\n        uint128 _gas,\\n        uint32 _size,\\n        uint128 _value\\n    ) internal pure onlyType3(_options) returns (bytes memory) {\\n        bytes memory option = ExecutorOptions.encodeLzReadOption(_gas, _size, _value);\\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_LZREAD, option);\\n    }\\n\\n    /**\\n     * @dev Adds an executor LZ compose option to the existing options.\\n     * @param _options The existing options container.\\n     * @param _index The index for the lzCompose() function call.\\n     * @param _gas The gasLimit for the lzCompose() function call.\\n     * @param _value The msg.value for the lzCompose() function call.\\n     * @return options The updated options container.\\n     *\\n     * @dev When multiples of this option are added, they are summed PER index by the executor on the remote chain.\\n     * @dev If the OApp sends N lzCompose calls on the remote, you must provide N incremented indexes starting with 0.\\n     * ie. When your remote OApp composes (N = 3) messages, you must set this option for index 0,1,2\\n     */\\n    function addExecutorLzComposeOption(\\n        bytes memory _options,\\n        uint16 _index,\\n        uint128 _gas,\\n        uint128 _value\\n    ) internal pure onlyType3(_options) returns (bytes memory) {\\n        bytes memory option = ExecutorOptions.encodeLzComposeOption(_index, _gas, _value);\\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_LZCOMPOSE, option);\\n    }\\n\\n    /**\\n     * @dev Adds an executor ordered execution option to the existing options.\\n     * @param _options The existing options container.\\n     * @return options The updated options container.\\n     */\\n    function addExecutorOrderedExecutionOption(\\n        bytes memory _options\\n    ) internal pure onlyType3(_options) returns (bytes memory) {\\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_ORDERED_EXECUTION, bytes(\\\"\\\"));\\n    }\\n\\n    /**\\n     * @dev Adds a DVN pre-crime option to the existing options.\\n     * @param _options The existing options container.\\n     * @param _dvnIdx The DVN index for the pre-crime option.\\n     * @return options The updated options container.\\n     */\\n    function addDVNPreCrimeOption(\\n        bytes memory _options,\\n        uint8 _dvnIdx\\n    ) internal pure onlyType3(_options) returns (bytes memory) {\\n        return addDVNOption(_options, _dvnIdx, DVNOptions.OPTION_TYPE_PRECRIME, bytes(\\\"\\\"));\\n    }\\n\\n    /**\\n     * @dev Adds an executor option to the existing options.\\n     * @param _options The existing options container.\\n     * @param _optionType The type of the executor option.\\n     * @param _option The encoded data for the executor option.\\n     * @return options The updated options container.\\n     */\\n    function addExecutorOption(\\n        bytes memory _options,\\n        uint8 _optionType,\\n        bytes memory _option\\n    ) internal pure onlyType3(_options) returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                _options,\\n                ExecutorOptions.WORKER_ID,\\n                _option.length.toUint16() + 1, // +1 for optionType\\n                _optionType,\\n                _option\\n            );\\n    }\\n\\n    /**\\n     * @dev Adds a DVN option to the existing options.\\n     * @param _options The existing options container.\\n     * @param _dvnIdx The DVN index for the DVN option.\\n     * @param _optionType The type of the DVN option.\\n     * @param _option The encoded data for the DVN option.\\n     * @return options The updated options container.\\n     */\\n    function addDVNOption(\\n        bytes memory _options,\\n        uint8 _dvnIdx,\\n        uint8 _optionType,\\n        bytes memory _option\\n    ) internal pure onlyType3(_options) returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                _options,\\n                DVNOptions.WORKER_ID,\\n                _option.length.toUint16() + 2, // +2 for optionType and dvnIdx\\n                _dvnIdx,\\n                _optionType,\\n                _option\\n            );\\n    }\\n\\n    /**\\n     * @dev Encodes legacy options of type 1.\\n     * @param _executionGas The gasLimit value passed to lzReceive().\\n     * @return legacyOptions The encoded legacy options.\\n     */\\n    function encodeLegacyOptionsType1(uint256 _executionGas) internal pure returns (bytes memory) {\\n        if (_executionGas > type(uint128).max) revert InvalidSize(type(uint128).max, _executionGas);\\n        return abi.encodePacked(TYPE_1, _executionGas);\\n    }\\n\\n    /**\\n     * @dev Encodes legacy options of type 2.\\n     * @param _executionGas The gasLimit value passed to lzReceive().\\n     * @param _nativeForDst The amount of native air dropped to the receiver.\\n     * @param _receiver The _nativeForDst receiver address.\\n     * @return legacyOptions The encoded legacy options of type 2.\\n     */\\n    function encodeLegacyOptionsType2(\\n        uint256 _executionGas,\\n        uint256 _nativeForDst,\\n        bytes memory _receiver // @dev Use bytes instead of bytes32 in legacy type 2 for _receiver.\\n    ) internal pure returns (bytes memory) {\\n        if (_executionGas > type(uint128).max) revert InvalidSize(type(uint128).max, _executionGas);\\n        if (_nativeForDst > type(uint128).max) revert InvalidSize(type(uint128).max, _nativeForDst);\\n        if (_receiver.length > 32) revert InvalidSize(32, _receiver.length);\\n        return abi.encodePacked(TYPE_2, _executionGas, _nativeForDst, _receiver);\\n    }\\n}\\n\",\"keccak256\":\"0xd40d91e8173cdb5bb821b4594f806b99344d5fd605bc6f2cf0fb21d5ab2500e3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xff6d0bb2e285473e5311d9d3caacb525ae3538a80758c10649a4d61029b017bb\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity >=0.6.2;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC-721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC-721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\\n     *   {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC-721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the address zero.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xf78f05f3b8c9f75570e85300d7b4600d7f6f6a198449273f31d44c1641adb46f\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0x493033a8d1b176a037b2cc6a04dad01a5c157722049bbecf632ca876224dd4b2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity >=0.4.16;\\n\\n/**\\n * @dev Interface of the ERC-165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x8891738ffe910f0cf2da09566928589bf5d63f4524dd734fd9cedbac3274dd5c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Value doesn't fit in an uint of `bits` size.\\n     */\\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\\n\\n    /**\\n     * @dev An int value doesn't fit in an uint of `bits` size.\\n     */\\n    error SafeCastOverflowedIntToUint(int256 value);\\n\\n    /**\\n     * @dev Value doesn't fit in an int of `bits` size.\\n     */\\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\\n\\n    /**\\n     * @dev An uint value doesn't fit in an int of `bits` size.\\n     */\\n    error SafeCastOverflowedUintToInt(uint256 value);\\n\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        if (value > type(uint248).max) {\\n            revert SafeCastOverflowedUintDowncast(248, value);\\n        }\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        if (value > type(uint240).max) {\\n            revert SafeCastOverflowedUintDowncast(240, value);\\n        }\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        if (value > type(uint232).max) {\\n            revert SafeCastOverflowedUintDowncast(232, value);\\n        }\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        if (value > type(uint224).max) {\\n            revert SafeCastOverflowedUintDowncast(224, value);\\n        }\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        if (value > type(uint216).max) {\\n            revert SafeCastOverflowedUintDowncast(216, value);\\n        }\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        if (value > type(uint208).max) {\\n            revert SafeCastOverflowedUintDowncast(208, value);\\n        }\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        if (value > type(uint200).max) {\\n            revert SafeCastOverflowedUintDowncast(200, value);\\n        }\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        if (value > type(uint192).max) {\\n            revert SafeCastOverflowedUintDowncast(192, value);\\n        }\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        if (value > type(uint184).max) {\\n            revert SafeCastOverflowedUintDowncast(184, value);\\n        }\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        if (value > type(uint176).max) {\\n            revert SafeCastOverflowedUintDowncast(176, value);\\n        }\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        if (value > type(uint168).max) {\\n            revert SafeCastOverflowedUintDowncast(168, value);\\n        }\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        if (value > type(uint160).max) {\\n            revert SafeCastOverflowedUintDowncast(160, value);\\n        }\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        if (value > type(uint152).max) {\\n            revert SafeCastOverflowedUintDowncast(152, value);\\n        }\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        if (value > type(uint144).max) {\\n            revert SafeCastOverflowedUintDowncast(144, value);\\n        }\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        if (value > type(uint136).max) {\\n            revert SafeCastOverflowedUintDowncast(136, value);\\n        }\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        if (value > type(uint128).max) {\\n            revert SafeCastOverflowedUintDowncast(128, value);\\n        }\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        if (value > type(uint120).max) {\\n            revert SafeCastOverflowedUintDowncast(120, value);\\n        }\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        if (value > type(uint112).max) {\\n            revert SafeCastOverflowedUintDowncast(112, value);\\n        }\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        if (value > type(uint104).max) {\\n            revert SafeCastOverflowedUintDowncast(104, value);\\n        }\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        if (value > type(uint96).max) {\\n            revert SafeCastOverflowedUintDowncast(96, value);\\n        }\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        if (value > type(uint88).max) {\\n            revert SafeCastOverflowedUintDowncast(88, value);\\n        }\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        if (value > type(uint80).max) {\\n            revert SafeCastOverflowedUintDowncast(80, value);\\n        }\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        if (value > type(uint72).max) {\\n            revert SafeCastOverflowedUintDowncast(72, value);\\n        }\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        if (value > type(uint64).max) {\\n            revert SafeCastOverflowedUintDowncast(64, value);\\n        }\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        if (value > type(uint56).max) {\\n            revert SafeCastOverflowedUintDowncast(56, value);\\n        }\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        if (value > type(uint48).max) {\\n            revert SafeCastOverflowedUintDowncast(48, value);\\n        }\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        if (value > type(uint40).max) {\\n            revert SafeCastOverflowedUintDowncast(40, value);\\n        }\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        if (value > type(uint32).max) {\\n            revert SafeCastOverflowedUintDowncast(32, value);\\n        }\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        if (value > type(uint24).max) {\\n            revert SafeCastOverflowedUintDowncast(24, value);\\n        }\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        if (value > type(uint16).max) {\\n            revert SafeCastOverflowedUintDowncast(16, value);\\n        }\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        if (value > type(uint8).max) {\\n            revert SafeCastOverflowedUintDowncast(8, value);\\n        }\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        if (value < 0) {\\n            revert SafeCastOverflowedIntToUint(value);\\n        }\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(248, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(240, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(232, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(224, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(216, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(208, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(200, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(192, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(184, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(176, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(168, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(160, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(152, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(144, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(136, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(128, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(120, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(112, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(104, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(96, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(88, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(80, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(72, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(64, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(56, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(48, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(40, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(32, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(24, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(16, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(8, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        if (value > uint256(type(int256).max)) {\\n            revert SafeCastOverflowedUintToInt(value);\\n        }\\n        return int256(value);\\n    }\\n\\n    /**\\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\\n     */\\n    function toUint(bool b) internal pure returns (uint256 u) {\\n        assembly (\\\"memory-safe\\\") {\\n            u := iszero(iszero(b))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x195533c86d0ef72bcc06456a4f66a9b941f38eb403739b00f21fd7c1abd1ae54\",\"license\":\"MIT\"},\"contracts/StrategyBuilderFeeReduction.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.22;\\n\\nimport { IStrategyBuilderFeeReduction } from \\\"./interfaces/IStrategyBuilderFeeReduction.sol\\\";\\nimport { OptionsBuilder } from \\\"@layerzerolabs/oapp-evm/contracts/oapp/libs/OptionsBuilder.sol\\\";\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport { IERC721 } from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport { IStrategyVault } from \\\"./interfaces/IStrategyVault.sol\\\";\\nimport { ITieredTokenLocker } from \\\"../contracts/interfaces/ITieredTokenLocker.sol\\\";\\nimport { ICryptoOctoRarityRegistry } from \\\"../contracts/interfaces/ICryptoOctoRarityRegistry.sol\\\";\\nimport { IStrategyBuilderFeeReductionRouter } from \\\"./interfaces/IStrategyBuilderFeeReductionRouter.sol\\\";\\nimport { IStrategyVaultFactory } from \\\"./interfaces/IStrategyVaultFactory.sol\\\";\\n\\n/**\\n * @title FeeReduction\\n * @author 3Blocks UG\\n * @notice Provides a unified fee reduction mechanism based on:\\n * 1) Token lock tiers\\n * 2) Deposited NFT rarity\\n *\\n * @dev This contract resolves the effective user address in case the provided\\n * wallet is a StrategyVault contract by:\\n * - Checking ERC165 supportsInterface for IStrategyVault\\n * - Resolving the underlying owner() if applicable\\n *\\n * The final fee reduction is defined as the maximum of:\\n * - The reduction derived from the user's lock tier\\n * - The reduction derived from the deposited NFT rarity\\n *\\n * Fee reductions are expressed in basis points (bps),\\n * where 10_000 = 100%.\\n *\\n * This contract is designed to be read-only for fee logic,\\n * except for explicit NFT deposit/withdrawal by users.\\n */\\ncontract StrategyBuilderFeeReduction is IStrategyBuilderFeeReduction {\\n    using OptionsBuilder for bytes;\\n\\n    // \\u250f\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2513\\n    // \\u2503    Constants    \\u2503\\n    // \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251b\\n\\n    /// @notice Divisor for percentage calculations (10000 = 100%).\\n    uint256 public constant PERCENTAGE_DIVISOR = 10000;\\n\\n    // \\u250f\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2513\\n    // \\u2503   State Variables    \\u2503\\n    // \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251b\\n\\n    /**\\n     * @notice Address of the Tiered Token Locker contract.\\n     * @dev Used to resolve the user's lock tier for fee reduction.\\n     */\\n    address public immutable lock;\\n    address public immutable router;\\n    address public immutable factory;\\n\\n    bytes4 public strategyVaultInterfaceId = 0x3d6efa61;\\n\\n    /**\\n     * @notice Mapping of user address to deposited NFT tokenId.\\n     * @dev Each user may deposit at most one NFT at a time.\\n     * A value of 0 indicates no NFT deposited.\\n     */\\n    mapping(address => TokenInfo) public userTokenInfos;\\n\\n    // \\u250f\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2513\\n    // \\u2503     Constructor     \\u2503\\n    // \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251b\\n\\n    constructor(address _lock, address _router, address _factory) {\\n        lock = _lock;\\n        router = _router;\\n        factory = _factory;\\n    }\\n\\n    receive() external payable {}\\n\\n    fallback() external payable {}\\n\\n    // \\u250f\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2513\\n    // \\u2503   Execution Functions     \\u2503\\n    // \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251b\\n\\n    function activateTokenForUser(address user, uint256 tokenId, uint8 rarity) external {\\n        if (msg.sender != router) {\\n            revert NotAllowed();\\n        }\\n\\n        if (userTokenInfos[user].tokenId != 0) {\\n            revert AlreadyTokenActive();\\n        }\\n\\n        userTokenInfos[user] = TokenInfo(tokenId, rarity);\\n\\n        emit Deposit(user, tokenId, rarity);\\n    }\\n\\n    /**\\n     * @notice Withdraws the previously deposited token.\\n     * @dev Resets the user's deposited token state and transfers\\n     * the token back to the user.\\n     *\\n     * Requirements:\\n     * - The caller must have a token deposited.\\n     *\\n     * Emits a {Withdraw} event.\\n     */\\n    function withdrawToken(uint128 customGasLimit) external {\\n        TokenInfo memory tokenInfo = userTokenInfos[msg.sender];\\n        uint256 tokenId = tokenInfo.tokenId;\\n\\n        if (tokenId == 0) {\\n            revert NoTokenActive();\\n        }\\n\\n        userTokenInfos[msg.sender] = TokenInfo(0, 0);\\n\\n        bytes memory payload = abi.encode(msg.sender, tokenId, tokenInfo.rarity);\\n\\n        // Set default options for LayerZero messaging\\n        bytes memory extraOptions = customGasLimit > 0\\n            ? OptionsBuilder.newOptions().addExecutorLzReceiveOption(customGasLimit, 0)\\n            : new bytes(0);\\n\\n        uint256 fee = IStrategyBuilderFeeReductionRouter(router).quoteSend(payload, extraOptions);\\n\\n        if (address(this).balance < fee) {\\n            revert OutOfFunds();\\n        }\\n\\n        IStrategyBuilderFeeReductionRouter(router).sendTokenDeactivation{ value: fee }(payload, extraOptions);\\n\\n        emit Withdraw(msg.sender, tokenId);\\n    }\\n\\n    // \\u250f\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2513\\n    // \\u2503   View Functions     \\u2503\\n    // \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251b\\n\\n    /**\\n     * @notice Returns the effective fee reduction for a given wallet.\\n     * @dev If the wallet is a StrategyVault, the underlying owner\\n     * is resolved and used for fee calculation.\\n     *\\n     * The returned reduction is the maximum of:\\n     * - Lock-tier based fee reduction\\n     * - NFT-rarity based fee reduction\\n     *\\n     * If neither applies, returns 0.\\n     *\\n     * @param wallet The wallet or StrategyVault address to query.\\n     * @return reduction The fee reduction in basis points (bps).\\n     */\\n    function getFeeReduction(address wallet) external view override returns (uint256) {\\n        address user = _resolveVaultOwner(wallet);\\n\\n        // \\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\n        // 1\\ufe0f\\u20e3 Lock-Tier\\n        // \\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\n        (, , ITieredTokenLocker.Tier lockTier, ) = ITieredTokenLocker(lock).getLockInfo(user);\\n        uint256 lockReduction = _tierToFeeReduction(lockTier);\\n\\n        // \\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\n        // 2\\ufe0f\\u20e3 NFT-Rarity\\n        // \\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\n        uint256 nftReduction = 0;\\n        TokenInfo memory tokenInfo = userTokenInfos[user];\\n        uint256 tokenId = tokenInfo.tokenId;\\n        if (tokenId != 0) {\\n            nftReduction = _rarityToFeeReduction(ICryptoOctoRarityRegistry.Rarity(tokenInfo.rarity));\\n        }\\n\\n        // \\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\n        // 3\\ufe0f\\u20e3 Max von Lock & NFT\\n        // \\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\n        uint256 maxReduction = lockReduction >= nftReduction ? lockReduction : nftReduction;\\n        return maxReduction;\\n    }\\n\\n    // \\u250f\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2513\\n    // \\u2503   Internal Functions   \\u2503\\n    // \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251b\\n\\n    /**\\n     * @notice Maps a lock tier to a fee reduction in basis points.\\n     * @dev Returns 0 for Tier.None or unknown tiers.\\n     */\\n    function _tierToFeeReduction(ITieredTokenLocker.Tier tier) internal pure returns (uint256) {\\n        // Tier-based fee reductions in basis points\\n        if (tier == ITieredTokenLocker.Tier.Basic) return 500; // 5%\\n        if (tier == ITieredTokenLocker.Tier.Bronze) return 750; // 7.5%\\n        if (tier == ITieredTokenLocker.Tier.Silver) return 1000; // 10%\\n        if (tier == ITieredTokenLocker.Tier.Gold) return 1500; // 15%\\n        if (tier == ITieredTokenLocker.Tier.Diamond) return 2500; // 25%\\n        return 0; // Tier.None or unknown\\n    }\\n\\n    /**\\n     * @notice Maps an NFT rarity to a fee reduction in basis points.\\n     * @dev Only Gold and Diamond rarities currently grant reductions.\\n     */\\n    function _rarityToFeeReduction(ICryptoOctoRarityRegistry.Rarity rarity) internal pure returns (uint256) {\\n        if (rarity == ICryptoOctoRarityRegistry.Rarity.Gold) return 5000; // 50%\\n        if (rarity == ICryptoOctoRarityRegistry.Rarity.Diamond) return 5000; // 50%\\n        return 0;\\n    }\\n\\n    /**\\n     * @notice Resolves the effective user address for fee calculations.\\n     * @dev If the wallet is an EOA, it is returned directly.\\n     *\\n     * If the wallet is a contract, this function attempts to:\\n     * 1. Detect if it supports the IStrategyVault interface via ERC165.\\n     * 2. If so, attempt to resolve the underlying owner() address.\\n     *\\n     * If any step fails (revert, invalid return data, zero owner),\\n     * the original wallet address is used as a safe fallback.\\n     *\\n     * This ensures robustness against:\\n     * - Non-compliant contracts\\n     * - Malicious or reverting implementations\\n     * - Unexpected ABI behavior\\n     *\\n     * @param wallet The wallet or contract address to resolve.\\n     * @return resolved The resolved owner or original wallet address.\\n     */\\n    function _resolveVaultOwner(address wallet) public view returns (address) {\\n        // EOA\\n        if (wallet.code.length == 0) return wallet;\\n\\n        // \\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\n        // 1\\ufe0f\\u20e3 Check if wallet is a deployed strategy vault\\n        // \\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\n        bool isStrategyVault = IStrategyVaultFactory(factory).isDeployedVault(wallet);\\n\\n        // No strategy vault\\n        if (!isStrategyVault) return wallet;\\n\\n        // \\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\n        // 2\\ufe0f\\u20e3 Try owner()\\n        // \\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\n        address owner = Ownable(wallet).owner();\\n\\n        if (owner == address(0)) return wallet;\\n\\n        return owner;\\n    }\\n}\\n\",\"keccak256\":\"0x065c3e9c4a1da911214adecbaf612b8110ccb3c39f842144cd3b761fddd60c51\",\"license\":\"MIT\"},\"contracts/interfaces/ICryptoOctoRarityRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.22;\\n\\ninterface ICryptoOctoRarityRegistry {\\n    enum Rarity {\\n        Classic,\\n        Bronze,\\n        Silver,\\n        Gold,\\n        Diamond\\n    }\\n\\n    function getRarity(uint256 tokenId) external view returns (Rarity);\\n}\\n\",\"keccak256\":\"0x276b2a60167a7c9ad479c216d5ff935be726080a9e612380f20082865777bd31\",\"license\":\"MIT\"},\"contracts/interfaces/IFeeReduction.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.22;\\n\\ninterface IFeeReduction {\\n    function getFeeReduction(address wallet) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x7804bb35e364bab71d606165a41c6f6e2ba636afc4715405719bcc5158a4db41\",\"license\":\"MIT\"},\"contracts/interfaces/IStrategyBuilderFeeReduction.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.22;\\n\\nimport { IFeeReduction } from \\\"./IFeeReduction.sol\\\";\\n\\n/**\\n * @title IStrategyBuilderFeeReduction\\n * @author 3Blocks\\n * @notice Interface for cross-chain fee reduction via StrategyBuilder.\\n *\\n * Provides unified fee reduction based on:\\n * 1. Tiered token locking (via ITieredTokenLocker)\\n * 2. NFT rarity activation (via cross-chain router deposit)\\n *\\n * Designed for use with LayerZero-enabled activation systems.\\n */\\ninterface IStrategyBuilderFeeReduction is IFeeReduction {\\n    // \\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\n    // Errors\\n    // \\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\n\\n    /// @notice User already has an active deposited token\\n    error AlreadyTokenActive();\\n\\n    /// @notice User has no active token deposited\\n    error NoTokenActive();\\n\\n    /// @notice Caller is not allowed (router-only)\\n    error NotAllowed();\\n\\n    /// @notice Contract has insufficient native funds to send cross-chain message\\n    error OutOfFunds();\\n\\n    // \\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\n    // Structs\\n    // \\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\n\\n    /**\\n     * @notice Stores information about a deposited NFT for a user\\n     * @param tokenId The deposited NFT tokenId\\n     * @param rarity  The rarity classification of the NFT\\n     */\\n    struct TokenInfo {\\n        uint256 tokenId;\\n        uint8 rarity;\\n    }\\n\\n    // \\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\n    // Events\\n    // \\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\n\\n    /**\\n     * @notice Emitted when a token is deposited for a user\\n     * @param account The user receiving activation\\n     * @param tokenId The deposited NFT tokenId\\n     * @param rarity  The rarity of the deposited NFT\\n     */\\n    event Deposit(address indexed account, uint256 indexed tokenId, uint8 rarity);\\n\\n    /**\\n     * @notice Emitted when a user withdraws their deposited token\\n     * @param account The withdrawing user\\n     * @param tokenId The withdrawn tokenId\\n     */\\n    event Withdraw(address indexed account, uint256 indexed tokenId);\\n\\n    // \\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\n    // State Variables\\n    // \\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\n\\n    /// @notice Returns the TieredTokenLocker contract address\\n    function lock() external view returns (address);\\n\\n    /// @notice Returns the router allowed to deposit tokens\\n    function router() external view returns (address);\\n\\n    /**\\n     * @notice Returns the deposited token info for a given user\\n     * @param user The user address\\n     * @return tokenId The active deposited tokenId (0 if none)\\n     * @return rarity  The stored rarity value\\n     */\\n    function userTokenInfos(address user) external view returns (uint256 tokenId, uint8 rarity);\\n\\n    // \\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\n    // Execution Functions\\n    // \\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\n\\n    /**\\n     * @notice Deposits a token activation for a user\\n     * @dev Router-only function, called when an NFT activation message arrives cross-chain\\n     * Requirements:\\n     * - Caller must be router\\n     * - User must not already have an active token\\n     * Emits {Deposit}\\n     * @param user    The user receiving the activation\\n     * @param tokenId The activated NFT tokenId\\n     * @param rarity  The rarity classification of the NFT\\n     */\\n    function activateTokenForUser(address user, uint256 tokenId, uint8 rarity) external;\\n\\n    /**\\n     * @notice Withdraws the currently deposited NFT activation for the caller\\n     * Requirements:\\n     * - Caller must have an active token deposited\\n     * Emits {Withdraw}\\n     */\\n    function withdrawToken(uint128 customGasLimit) external;\\n\\n    // \\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\n    // Fee Reduction Logic\\n    // \\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\n\\n    /**\\n     * @notice Returns the fee reduction in basis points (bps) for a given wallet\\n     * @dev Fee reduction is defined as the maximum of:\\n     *  - Tier-based reduction\\n     *  - NFT rarity-based reduction\\n     * @param wallet The wallet or StrategyVault address\\n     * @return reduction Fee reduction in bps (0\\u201310000)\\n     */\\n    function getFeeReduction(address wallet) external view returns (uint256 reduction);\\n}\\n\",\"keccak256\":\"0xb5ad1518dfb7889bf97adff83b264800a1002ef38676e2dd3351a6ddd715c147\",\"license\":\"MIT\"},\"contracts/interfaces/IStrategyBuilderFeeReductionRouter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.22;\\n\\n/**\\n * @title IStrategyBuilderFeeReductionRouter\\n * @author 3Blocks\\n *\\n * @notice Interface for the LayerZero Router responsible for\\n * cross-chain activation/deactivation messaging for StrategyBuilderFeeReduction.\\n *\\n * This router:\\n * - Sends token deactivation messages back to the origin chain\\n * - Receives token activation messages from the origin chain\\n * - Forwards activation data into the FeeReduction contract\\n */\\ninterface IStrategyBuilderFeeReductionRouter {\\n    // \\u250f\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2513\\n    // \\u2503              Errors              \\u2503\\n    // \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251b\\n\\n    /// @notice Caller is not allowed (only FeeReduction contract may call)\\n    error NotAllowed();\\n\\n    /// @notice Thrown when the owner tries to set an invalid gas limit\\n    error GasLimitTooLow();\\n\\n    /// @notice Thrown when trying to withdraw with zero balance\\n    error NoFundsToWithdraw();\\n\\n    /// @notice Thrown when native transfer fails\\n    error WithdrawFailed();\\n\\n    // \\u250f\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2513\\n    // \\u2503              Events              \\u2503\\n    // \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251b\\n\\n    /// @notice Emitted when the owner withdraws native funds\\n    event NativeWithdrawn(address indexed owner, uint256 amount);\\n\\n    /// @notice Emitted when the owner updates the gas limit for LayerZero receive execution\\n    /// @param oldGasLimit Previous configured gas limit\\n    /// @param newGasLimit New configured gas limit\\n    event GasLimitUpdated(uint128 oldGasLimit, uint128 newGasLimit);\\n\\n    /**\\n     * @notice Emitted when a deactivation message is sent cross-chain.\\n     *\\n     * @param user    The user whose token is being deactivated\\n     * @param tokenId The tokenId being withdrawn\\n     * @param rarity  The rarity of the token\\n     */\\n    event TokenDeactivationSent(address indexed user, uint256 indexed tokenId, uint8 rarity);\\n\\n    /**\\n     * @notice Emitted when an activation message is received from another chain.\\n     *\\n     * @param user    The user receiving activation\\n     * @param tokenId The activated tokenId\\n     * @param rarity  The rarity of the activated NFT\\n     */\\n    event TokenActivationReceived(address indexed user, uint256 indexed tokenId, uint8 rarity);\\n\\n    // \\u250f\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2513\\n    // \\u2503        State Variables           \\u2503\\n    // \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251b\\n\\n    /**\\n     * @notice Returns the connected StrategyBuilderFeeReduction contract.\\n     */\\n    function strategyBuilderFeeReduction() external view returns (address);\\n\\n    /**\\n     * @notice Returns the destination LayerZero endpoint ID.\\n     */\\n    function destEid() external view returns (uint32);\\n\\n    // =============================================================\\n    // Owner Withdraw\\n    // =============================================================\\n\\n    /// @notice Withdraws all native coins from the contract\\n    /// @dev Only callable by the owner\\n    function withdrawNative() external;\\n\\n    // \\u250f\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2513\\n    // \\u2503        Messaging Functions       \\u2503\\n    // \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251b\\n\\n    /**\\n     * @notice Quotes the LayerZero native fee required to send a message.\\n     *\\n     * @param payload The encoded cross-chain message payload\\n     *\\n     * @return nativeFee     The required native gas fee\\n     */\\n    function quoteSend(bytes memory payload, bytes calldata extraOptions) external view returns (uint256);\\n\\n    /**\\n     * @notice Sends a token deactivation message to the origin chain.\\n     *\\n     * @dev Callable only by the StrategyBuilderFeeReduction contract.\\n     *\\n     * Requirements:\\n     * - Caller must equal strategyBuilderFeeReduction\\n     * - Must provide enough msg.value for LayerZero fees\\n     *\\n     * @param payload Encoded message containing (user, tokenId, rarity)\\n     */\\n    function sendTokenDeactivation(bytes memory payload, bytes calldata extraOptions) external payable;\\n}\\n\",\"keccak256\":\"0x4c2a91b304226b90cdf31683cf874331ee864d1356da11c6626cb5f86f86f9c3\",\"license\":\"MIT\"},\"contracts/interfaces/IStrategyVault.sol\":{\"content\":\"// SPDX-License-Identifier:MIT\\npragma solidity ^0.8.22;\\n\\ninterface IStrategyVault {\\n    // \\u250f\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2513\\n    // \\u2503     Structs / Enums       \\u2503\\n    // \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251b\\n\\n    enum FunctionId {\\n        USER_OP_VALIDATION_SESSION_KEY\\n    }\\n\\n    /// @dev Enum for different types of actions in the strategy.\\n    /// @notice Enum representing the type of action in an automation strategy.\\n    enum ActionType {\\n        EXTERNAL, // External action interacting with external contracts.\\n        INTERNAL_ACTION // Internal action interacting with IAction contracts.\\n    }\\n\\n    struct Call {\\n        // The target address for the account to call.\\n        address target;\\n        // The value to send with the call.\\n        uint256 value;\\n        // The calldata for the call.\\n        bytes data;\\n    }\\n\\n    /// @dev Struct representing a single action in a strategy.\\n    /// @notice Defines an action to be executed as part of a strategy, including the selector, parameters, target address, value, and action type.\\n    struct Action {\\n        bytes4 selector; // The function selector for the action.\\n        bytes parameter; // The parameters to be passed to the action.\\n        address target; // The target address to which the action is directed.\\n        uint256 value; // The value (in wei) to be sent along with the action.\\n        ActionType actionType; // The type of action (external or internal).\\n        ContextKey[] inputs;\\n        ContextKey output;\\n        uint8 result;\\n    }\\n\\n    struct ContextKey {\\n        bytes32 key;\\n        Parameter parameterReplacement;\\n    }\\n\\n    struct Parameter {\\n        uint256 offset; // Byte offset in parameter where replacement happens\\n        uint256 length; // Length of data to replace (32 for uint256, 20 for address)\\n        ParamType paramType; // Type of parameter being replaced\\n    }\\n\\n    enum ParamType {\\n        UINT256,\\n        ADDRESS,\\n        BYTES32,\\n        BOOL\\n    }\\n\\n    struct ActionContext {\\n        mapping(bytes32 => bytes) variables;\\n        mapping(bytes32 => address) addresses;\\n        mapping(bytes32 => uint256) amounts;\\n        mapping(bytes32 => bool) booleans;\\n    }\\n\\n    /// @dev Struct defining a condition that must be met for a strategy or automation to be executed.\\n    /// @notice Represents a condition that will determine the execution flow in a strategy.\\n    struct Condition {\\n        address conditionAddress; // The address of the contract providing the condition.\\n        uint32 id; // The ID of the condition.\\n        uint8 result1; // The index to jump to if the condition returns 1.\\n        uint8 result0; // The index to jump to if the condition returns 0.\\n    }\\n\\n    /// @dev Struct representing a single step in a strategy.\\n    /// @notice A strategy step includes a condition and associated actions to be executed.\\n    struct StrategyStep {\\n        Condition condition; // The condition that check if the actions in this step should executed.\\n        Action[] actions; // An array of actions to be executed if the condition is met.\\n    }\\n\\n    /// @dev Struct representing a strategy, consisting of multiple steps.\\n    /// @notice Defines a strategy with its creator and the series of steps that make up the strategy.\\n    struct Strategy {\\n        address creator; // The address of the creator of the strategy.\\n        StrategyStep[] steps; // The steps that make up the strategy.\\n        bytes32 contextId;\\n    }\\n\\n    /// @dev Struct representing an automation process that can be executed based on a condition.\\n    /// @notice Defines an automation linked to a strategy, with a condition and payment details.\\n    struct Automation {\\n        Condition condition; // The condition that must return 1 for the automation to execute.\\n        uint32 strategyId; // The ID of the strategy associated with the automation.\\n        address paymentToken; // The token used to pay the execution fees.\\n        uint256 maxFeeAmount; // The maximum fee amount the user is willing to pay in the automation.\\n    }\\n\\n    // \\u250f\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2513\\n    // \\u2503    Errors       \\u2503\\n    // \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251b\\n\\n    error InvalidID();\\n    error StrategyDoesNotExist();\\n    error StrategyAlreadyExist();\\n    error AutomationNotExecutable(address condition, uint32 id);\\n    error FeeExceedMaxFee();\\n    error AutomationNotExist();\\n    error AutomationAlreadyExist();\\n    error StrategyIsInUse();\\n    error changeAutomationInConditionFailed();\\n    error ChangeStrategyInConditionFailed();\\n    error UpdateConditionFailed(address condition, uint32 id);\\n    error PaymentTokenNotAllowed();\\n    error InvalidNextStepIndex();\\n    error InvalidStepArrayLength();\\n    error InvalidActionTarget();\\n    error InvalidConditionAddress();\\n    error InvalidCondition();\\n    error PluginExecutionFailed();\\n    error NoConditionOrActions(uint256 stepIndex);\\n    error InvalidContextKey();\\n\\n    // \\u250f\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2513\\n    // \\u2503     Events       \\u2503\\n    // \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251b\\n\\n    /**\\n     * @notice Emitted when the global feesEnabled flag is toggled\\n     * @dev Allows off-chain monitoring of fee payment availability across all executions\\n     * @param enabled True if fees are now enabled, false if disabled\\n     */\\n    event FeesEnabled(bool enabled);\\n\\n    /// @notice Event emitted when a strategy is created.\\n    /// @param strategyId The unique ID of the created strategy.\\n    /// @param creator The address of the strategy creator.\\n    /// @param strategy The details of the created strategy.\\n    /// @param contextId The used context for the strategy\\n    event StrategyCreated(uint32 strategyId, address creator, bytes32 contextId, Strategy strategy);\\n\\n    /// @notice Event emitted when a strategy is executed.\\n    /// @param strategyId The unique ID of the strategy being executed.\\n    event StrategyExecuted(uint32 strategyId);\\n\\n    /// @notice Event emitted when a strategy is deleted.\\n    /// @param strategyId The unique ID of the deleted strategy.\\n    event StrategyDeleted(uint32 strategyId);\\n\\n    /// @notice Event emitted when an automation is created.\\n    /// @param automationId The unique ID of the created automation.\\n    /// @param strategyId The ID of the strategy associated with the automation.\\n    /// @param condition The condition that must be met for the automation to execute.\\n    /// @param paymentToken The token used to pay the execution fees.\\n    /// @param maxFeeAmount The maximum fee the user is willing to pay.\\n    event AutomationCreated(\\n        uint32 automationId,\\n        uint32 strategyId,\\n        Condition condition,\\n        address paymentToken,\\n        uint256 maxFeeAmount\\n    );\\n\\n    /// @notice Event emitted when an automation is deleted.\\n    /// @param automationId The unique ID of the deleted automation.\\n    event AutomationDeleted(uint32 automationId);\\n\\n    /// @notice Event emitted when an automation is executed.\\n    /// @param automationId The unique ID of the automation being executed.\\n    /// @param paymentToken The token used to pay for the execution.\\n    /// @param feeInToken The amount of tokens paid for execution.\\n    /// @param feeInUSD The value of the fee in USD.\\n    event AutomationExecuted(uint32 automationId, address paymentToken, uint256 feeInToken, uint256 feeInUSD);\\n\\n    /// @notice Event emitted when a strategy step is executed.\\n    /// @param strategyId The unique ID of the strategy being executed.\\n    /// @param stepId The ID of the step being executed.\\n    /// @param actions The list of actions executed as part of the step.\\n    event StrategyStepExecuted(uint32 strategyId, uint32 stepId, Action[] actions);\\n\\n    /// @notice Event emitted when an action is executed.\\n    /// @param action The details of the action being executed.\\n    event ActionExecuted(Action action);\\n\\n    event ContextVariableStored(bytes32 indexed contextId, bytes32 key, bytes result);\\n\\n    // \\u250f\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2513\\n    // \\u2503     Public Functions       \\u2503\\n    // \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251b\\n\\n    /// @notice Creates a new strategy with a given ID, creator address, and strategy steps.\\n    /// @dev The strategy is stored in a mapping using a bytes32 key generated from the strategy ID and msg.sender.\\n    /// @param id The unique identifier for the strategy.\\n    /// @param creator The address of the strategy creator.\\n    /// @param steps An array of StrategyStep structs defining the sequence of actions and conditions in the strategy.\\n    function createStrategy(uint32 id, address creator, StrategyStep[] calldata steps) external;\\n\\n    function createStrategyWithExistingContext(\\n        uint32 id,\\n        address creator,\\n        StrategyStep[] calldata steps,\\n        bytes32 contextId\\n    ) external;\\n\\n    /// @notice Deletes a strategy associated with the caller's address and the given strategy ID.\\n    /// @dev Removes the strategy with the specified ID, ensuring the caller is the owner of the strategy.\\n    /// @param id The unique ID of the strategy to be deleted.\\n    function deleteStrategy(uint32 id) external;\\n\\n    /// @notice Executes the strategy associated with the given strategy ID.\\n    /// @dev Triggers the execution of the strategy identified by the provided ID.\\n    /// @param id The unique ID of the strategy to be executed.\\n    function executeStrategy(uint32 id) external;\\n\\n    /// @notice Creates a new automation linked to an existing strategy with specified execution conditions.\\n    /// @dev Stores an Action struct that references a strategy and defines a trigger condition for automated execution.\\n    /// @param id The user-defined identifier for the automation.\\n    /// @param strategyId The ID of the existing strategy this automation will execute.\\n    /// @param paymentToken The token address used to pay for execution fees.\\n    /// @param maxFeeInUSD The maximum fee (denominated in USD) the user is willing to pay for automation execution.\\n    /// @param condition The trigger condition that must be met to execute the strategy.\\n    function createAutomation(\\n        uint32 id,\\n        uint32 strategyId,\\n        address paymentToken,\\n        uint256 maxFeeInUSD,\\n        Condition calldata condition\\n    ) external;\\n\\n    /// @notice Deletes an automation associated with the caller's address and the given automation ID.\\n    /// @dev Removes the automation with the specified ID, ensuring the caller is the owner of the automation.\\n    /// @param id The unique ID of the automation to be deleted.\\n    function deleteAutomation(uint32 id) external;\\n\\n    /// @notice Executes an existing automation for a specific wallet and distributes fees.\\n    /// @dev Executes the strategy linked to the given automation ID if the condition is met.\\n    ///      A portion of the execution fee is sent to the specified beneficiary address.\\n    /// @param id The ID of the automation to execute.\\n    /// @param beneficary The address that will receive a portion of the execution fees as a reward.\\n    function executeAutomation(uint32 id, address beneficary) external;\\n\\n    /// @notice Stores or updates a typed variable in the caller's global context\\n    /// @dev Validates non-empty key and stores value with type-specific handling for efficient retrieval.\\n    ///      Raw bytes always stored; typed mappings populated when possible. Emits ContextVariableStored event.\\n    /// @param contextId Unique identifier for the strategy's shared context\\n    /// @param key Non-empty string identifier for the context variable\\n    /// @param paramType Expected data type for storage and subsequent retrieval\\n    /// @param value Raw bytes value to store in the context\\n    function storeConextVariable(bytes32 contextId, bytes32 key, ParamType paramType, bytes memory value) external;\\n\\n    function execute(address target, uint256 value, bytes calldata data) external payable returns (bytes memory result);\\n\\n    function executeBatch(Call[] calldata calls) external payable returns (bytes[] memory results);\\n\\n    // \\u250f\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2513\\n    // \\u2503     View Functions      \\u2503\\n    // \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251b\\n\\n    /// @notice Retrieves the strategy associated with the given wallet and strategy ID.\\n    /// @dev Returns the strategy details stored for the specified wallet and strategy ID.\\n    /// @param id The unique ID of the strategy to be fetched.\\n    /// @return The Strategy struct associated with the given wallet and ID.\\n    function strategy(uint32 id) external view returns (Strategy memory);\\n\\n    /// @notice Retrieves the automation associated with the given wallet and automation ID.\\n    /// @dev Returns the automation details stored for the specified wallet and automation ID.\\n    /// @param id The unique ID of the automation to be fetched.\\n    /// @return The Automation struct associated with the given wallet and ID.\\n    function automation(uint32 id) external view returns (Automation memory);\\n\\n    /// @notice Retrieves a stored context variable value as raw bytes\\n    /// @dev Returns the raw bytes value from the variables mapping for a given context and key\\n    ///      For type-specific access, use dedicated view functions or off-chain ABI decoding\\n    ///      Empty bytes returned if variable doesn't exist in the specified context\\n    /// @param contextId Identifier of the strategy context containing the variable\\n    /// @param key  identifier of the specific context variable to retrieve\\n    /// @return value Raw bytes value stored for the specified key, or empty bytes if not set\\n    function getContextVariable(bytes32 contextId, bytes32 key) external view returns (bytes memory);\\n}\\n\",\"keccak256\":\"0xd544bb74b8b71178d42fca2a3b5ab689e91f0b23070b754866dbcf108919451b\",\"license\":\"MIT\"},\"contracts/interfaces/IStrategyVaultFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.22;\\n\\ninterface IStrategyVaultFactory {\\n    // \\u250f\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2513\\n    // \\u2503       Deployment          \\u2503\\n    // \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251b\\n\\n    function deployVaultDeterministic(bytes32 salt) external returns (address proxyAddress);\\n\\n    // \\u250f\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2513\\n    // \\u2503    Implementation        \\u2503\\n    // \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251b\\n\\n    function setImplementation(address _implementation) external;\\n\\n    function getImplementation() external view returns (address);\\n\\n    // \\u250f\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2513\\n    // \\u2503    Configuration         \\u2503\\n    // \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251b\\n\\n    function setConfiguration(address _feeController, address _feeHandler, address _actionRegistry) external;\\n\\n    // \\u250f\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2513\\n    // \\u2503    Vault Info / Checks    \\u2503\\n    // \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251b\\n\\n    function getDeployedVaultsCount() external view returns (uint256);\\n\\n    function getUserVaults(address user) external view returns (address[] memory);\\n\\n    function getUserVaultsCount(address user) external view returns (uint256);\\n\\n    function getVaultAt(uint256 index) external view returns (address);\\n\\n    function getUserVaultAt(address user, uint256 index) external view returns (address);\\n\\n    function isDeployedVault(address vault) external view returns (bool);\\n\\n    function getDeployedVaults(uint256 offset, uint256 limit) external view returns (address[] memory);\\n}\\n\",\"keccak256\":\"0xb4d89dbf30383a93e14d9a80aa2619012d138d22070768ecfef1e6512dd1726b\",\"license\":\"MIT\"},\"contracts/interfaces/ITieredTokenLocker.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.22;\\n\\ninterface ITieredTokenLocker {\\n    // Tier enumeration\\n    enum Tier {\\n        None,\\n        Basic,\\n        Bronze,\\n        Silver,\\n        Gold,\\n        Diamond\\n    }\\n\\n    // Lock information for each user\\n    struct LockInfo {\\n        uint256 amount; // Total locked amount\\n        uint256 lastDepositTime; // Timestamp of last deposit\\n        Tier currentTier; // Current tier level\\n        bool exists; // Whether lock exists\\n    }\\n\\n    function getLockInfo(\\n        address user\\n    ) external view returns (uint256 amount, uint256 unlockTime, Tier tier, bool canUnlock);\\n}\\n\",\"keccak256\":\"0x769ee858a30180468b3725abb48e2157a4d28493f83f0a5c0f6b5470afc5c43d\",\"license\":\"MIT\"},\"solidity-bytes-utils/contracts/BytesLib.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gon\\u00e7alo S\\u00e1 <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\npragma solidity >=0.8.0 <0.9.0;\\n\\n\\nlibrary BytesLib {\\n    function concat(\\n        bytes memory _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // Store the length of the first bytes array at the beginning of\\n            // the memory for tempBytes.\\n            let length := mload(_preBytes)\\n            mstore(tempBytes, length)\\n\\n            // Maintain a memory counter for the current write location in the\\n            // temp bytes array by adding the 32 bytes for the array length to\\n            // the starting location.\\n            let mc := add(tempBytes, 0x20)\\n            // Stop copying when the memory counter reaches the length of the\\n            // first bytes array.\\n            let end := add(mc, length)\\n\\n            for {\\n                // Initialize a copy counter to the start of the _preBytes data,\\n                // 32 bytes into its memory.\\n                let cc := add(_preBytes, 0x20)\\n            } lt(mc, end) {\\n                // Increase both counters by 32 bytes each iteration.\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                // Write the _preBytes data into the tempBytes memory 32 bytes\\n                // at a time.\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Add the length of _postBytes to the current length of tempBytes\\n            // and store it as the new length in the first 32 bytes of the\\n            // tempBytes memory.\\n            length := mload(_postBytes)\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n            // Move the memory counter back from a multiple of 0x20 to the\\n            // actual end of the _preBytes data.\\n            mc := end\\n            // Stop copying when the memory counter reaches the new combined\\n            // length of the arrays.\\n            end := add(mc, length)\\n\\n            for {\\n                let cc := add(_postBytes, 0x20)\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Update the free-memory pointer by padding our last write location\\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n            // next 32 byte block, then round down to the nearest multiple of\\n            // 32. If the sum of the length of the two arrays is zero then add\\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n            mstore(0x40, and(\\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n              not(31) // Round down to the nearest 32 bytes.\\n            ))\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\\n        assembly {\\n            // Read the first 32 bytes of _preBytes storage, which is the length\\n            // of the array. (We don't need to use the offset into the slot\\n            // because arrays use the entire slot.)\\n            let fslot := sload(_preBytes.slot)\\n            // Arrays of 31 bytes or less have an even value in their slot,\\n            // while longer arrays have an odd value. The actual length is\\n            // the slot divided by two for odd values, and the lowest order\\n            // byte divided by two for even values.\\n            // If the slot is even, bitwise and the slot with 255 and divide by\\n            // two to get the length. If the slot is odd, bitwise and the slot\\n            // with -1 and divide by two.\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n            let newlength := add(slength, mlength)\\n            // slength can contain both the length and contents of the array\\n            // if length < 32 bytes so let's prepare for that\\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n            switch add(lt(slength, 32), lt(newlength, 32))\\n            case 2 {\\n                // Since the new array still fits in the slot, we just need to\\n                // update the contents of the slot.\\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\\n                sstore(\\n                    _preBytes.slot,\\n                    // all the modifications to the slot are inside this\\n                    // next block\\n                    add(\\n                        // we can just add to the slot contents because the\\n                        // bytes we want to change are the LSBs\\n                        fslot,\\n                        add(\\n                            mul(\\n                                div(\\n                                    // load the bytes from memory\\n                                    mload(add(_postBytes, 0x20)),\\n                                    // zero all bytes to the right\\n                                    exp(0x100, sub(32, mlength))\\n                                ),\\n                                // and now shift left the number of bytes to\\n                                // leave space for the length in the slot\\n                                exp(0x100, sub(32, newlength))\\n                            ),\\n                            // increase length by the double of the memory\\n                            // bytes length\\n                            mul(mlength, 2)\\n                        )\\n                    )\\n                )\\n            }\\n            case 1 {\\n                // The stored value fits in the slot, but the combined value\\n                // will exceed it.\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // The contents of the _postBytes array start 32 bytes into\\n                // the structure. Our first read should obtain the `submod`\\n                // bytes that can fit into the unused space in the last word\\n                // of the stored array. To get this, we read 32 bytes starting\\n                // from `submod`, so the data we read overlaps with the array\\n                // contents by `submod` bytes. Masking the lowest-order\\n                // `submod` bytes allows us to add that value directly to the\\n                // stored value.\\n\\n                let submod := sub(32, slength)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(\\n                    sc,\\n                    add(\\n                        and(\\n                            fslot,\\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\\n                        ),\\n                        and(mload(mc), mask)\\n                    )\\n                )\\n\\n                for {\\n                    mc := add(mc, 0x20)\\n                    sc := add(sc, 1)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n            default {\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                // Start copying to the last used word of the stored array.\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // Copy over the first `submod` bytes of the new data as in\\n                // case 1 above.\\n                let slengthmod := mod(slength, 32)\\n                let mlengthmod := mod(mlength, 32)\\n                let submod := sub(32, slengthmod)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\\n\\n                for {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n        }\\n    }\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        // We're using the unchecked block below because otherwise execution ends \\n        // with the native overflow error code.\\n        unchecked {\\n            require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        }\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\\n        require(_bytes.length >= _start + 1 , \\\"toUint8_outOfBounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\\n        require(_bytes.length >= _start + 2, \\\"toUint16_outOfBounds\\\");\\n        uint16 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x2), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\\n        require(_bytes.length >= _start + 4, \\\"toUint32_outOfBounds\\\");\\n        uint32 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x4), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\\n        require(_bytes.length >= _start + 8, \\\"toUint64_outOfBounds\\\");\\n        uint64 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x8), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\\n        require(_bytes.length >= _start + 12, \\\"toUint96_outOfBounds\\\");\\n        uint96 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0xc), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\\n        require(_bytes.length >= _start + 16, \\\"toUint128_outOfBounds\\\");\\n        uint128 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x10), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\\n        require(_bytes.length >= _start + 32, \\\"toUint256_outOfBounds\\\");\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\\n        require(_bytes.length >= _start + 32, \\\"toBytes32_outOfBounds\\\");\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n\\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            let length := mload(_preBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(length, mload(_postBytes))\\n            case 1 {\\n                // cb is a circuit breaker in the for loop since there's\\n                //  no said feature for inline assembly loops\\n                // cb = 1 - don't breaker\\n                // cb = 0 - break\\n                let cb := 1\\n\\n                let mc := add(_preBytes, 0x20)\\n                let end := add(mc, length)\\n\\n                for {\\n                    let cc := add(_postBytes, 0x20)\\n                // the next line is the loop condition:\\n                // while(uint256(mc < end) + cb == 2)\\n                } eq(add(lt(mc, end), cb), 2) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    // if any of these checks fails then arrays are not equal\\n                    if iszero(eq(mload(mc), mload(cc))) {\\n                        // unsuccess:\\n                        success := 0\\n                        cb := 0\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n\\n    function equalStorage(\\n        bytes storage _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        bool success = true;\\n\\n        assembly {\\n            // we know _preBytes_offset is 0\\n            let fslot := sload(_preBytes.slot)\\n            // Decode the length of the stored array like in concatStorage().\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(slength, mlength)\\n            case 1 {\\n                // slength can contain both the length and contents of the array\\n                // if length < 32 bytes so let's prepare for that\\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n                if iszero(iszero(slength)) {\\n                    switch lt(slength, 32)\\n                    case 1 {\\n                        // blank the last byte which is the length\\n                        fslot := mul(div(fslot, 0x100), 0x100)\\n\\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\\n                            // unsuccess:\\n                            success := 0\\n                        }\\n                    }\\n                    default {\\n                        // cb is a circuit breaker in the for loop since there's\\n                        //  no said feature for inline assembly loops\\n                        // cb = 1 - don't breaker\\n                        // cb = 0 - break\\n                        let cb := 1\\n\\n                        // get the keccak hash to get the contents of the array\\n                        mstore(0x0, _preBytes.slot)\\n                        let sc := keccak256(0x0, 0x20)\\n\\n                        let mc := add(_postBytes, 0x20)\\n                        let end := add(mc, mlength)\\n\\n                        // the next line is the loop condition:\\n                        // while(uint256(mc < end) + cb == 2)\\n                        for {} eq(add(lt(mc, end), cb), 2) {\\n                            sc := add(sc, 1)\\n                            mc := add(mc, 0x20)\\n                        } {\\n                            if iszero(eq(sload(sc), mload(mc))) {\\n                                // unsuccess:\\n                                success := 0\\n                                cb := 0\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n}\\n\",\"keccak256\":\"0xf4b07e5d8f69407bb43c6db224adfcf6c73b512dd64e85008ac3c222910c3555\",\"license\":\"Unlicense\"}},\"version\":1}",
  "bytecode": "0x60e06040526000805463ffffffff1916633d6efa6117905534801561002357600080fd5b50604051610f23380380610f238339810160408190526100429161007b565b6001600160a01b0392831660805290821660a0521660c0526100be565b80516001600160a01b038116811461007657600080fd5b919050565b60008060006060848603121561009057600080fd5b6100998461005f565b92506100a76020850161005f565b91506100b56040850161005f565b90509250925092565b60805160a05160c051610e136101106000396000818161017501526102b0015260008181610234015281816103b9015281816105c8015261068f01526000818161020001526107600152610e136000f3fe60806040526004361061008f5760003560e01c8063caf2976511610056578063caf2976514610197578063e474ad9a146101bb578063f83d08ba146101ee578063f887ea4014610222578063fdfdc29c1461025657005b8063270928ea146100985780637e0cf529146100d5578063ae4df4b4146100f5578063b039492214610143578063c45a01551461016357005b3661009657005b005b3480156100a457600080fd5b506100b86100b3366004610b57565b610276565b6040516001600160a01b0390911681526020015b60405180910390f35b3480156100e157600080fd5b506100966100f0366004610b74565b6103ae565b34801561010157600080fd5b5061012c610110366004610b57565b6001602081905260009182526040909120805491015460ff1682565b6040805192835260ff9091166020830152016100cc565b34801561014f57600080fd5b5061009661015e366004610bbc565b6104b1565b34801561016f57600080fd5b506100b87f000000000000000000000000000000000000000000000000000000000000000081565b3480156101a357600080fd5b506101ad61271081565b6040519081526020016100cc565b3480156101c757600080fd5b506000546101d59060e01b81565b6040516001600160e01b031990911681526020016100cc565b3480156101fa57600080fd5b506100b87f000000000000000000000000000000000000000000000000000000000000000081565b34801561022e57600080fd5b506100b87f000000000000000000000000000000000000000000000000000000000000000081565b34801561026257600080fd5b506101ad610271366004610b57565b61072f565b6000816001600160a01b03163b60000361028e575090565b60405163a26b2a1760e01b81526001600160a01b0383811660048301526000917f00000000000000000000000000000000000000000000000000000000000000009091169063a26b2a1790602401602060405180830381865afa1580156102f9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061031d9190610bfa565b90508061032b575090919050565b6000836001600160a01b0316638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561036b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061038f9190610c15565b90506001600160a01b0381166103a757509192915050565b9392505050565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146103f757604051631eb49d6d60e11b815260040160405180910390fd5b6001600160a01b0383166000908152600160205260409020541561042e5760405163bc63666f60e01b815260040160405180910390fd5b60408051808201825283815260ff83811660208084018281526001600160a01b038916600081815260018085529088902096518755915195909101805460ff19169590941694909417909255925192835284927ff763e680fce25a97ffd55d8b705370c98b47b2285f7b3b2900c43606fd418045910160405180910390a3505050565b3360009081526001602081815260408084208151808301909252805480835293015460ff1691810191909152918190036104fe5760405163dfba2be560e01b815260040160405180910390fd5b6040805180820182526000808252602080830182815233808452600180845286852095518655915194909101805460ff191660ff95861617905586820151855192830191909152938101859052929091166060830152906080016040516020818303038152906040529050600080856001600160801b03161161058f576040805160008152602081019091526105c2565b6105c28560006105bb60408051600360f01b602082015281516002818303018152602290910190915290565b919061085f565b905060007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663cbb02ae984846040518363ffffffff1660e01b8152600401610614929190610c82565b602060405180830381865afa158015610631573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106559190610cb0565b90508047101561067857604051632e626a7160e11b815260040160405180910390fd5b604051630af8b70960e01b81526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690630af8b7099083906106c89087908790600401610c82565b6000604051808303818588803b1580156106e157600080fd5b505af11580156106f5573d6000803e3d6000fd5b50506040518793503392507f884edad9ce6fa2440d8a54cc123490eb96d2768479d49ff9c7366125a94243649150600090a3505050505050565b60008061073b83610276565b604051637238ccdb60e01b81526001600160a01b0380831660048301529192506000917f00000000000000000000000000000000000000000000000000000000000000001690637238ccdb90602401608060405180830381865afa1580156107a7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107cb9190610cc9565b509250505060006107db826108cc565b6001600160a01b03841660009081526001602081815260408084208151808301909252805480835293015460ff169181019190915292935090919080156108405761083d826020015160ff16600481111561083857610838610d15565b610980565b92505b6000838510156108505783610852565b845b9998505050505050505050565b606083600361086f8260006109c6565b61ffff16146108a8576108838160006109c6565b604051633a51740d60e01b815261ffff90911660048201526024015b60405180910390fd5b60006108b48585610a29565b90506108c286600183610aa1565b9695505050505050565b600060018260058111156108e2576108e2610d15565b036108f057506101f4919050565b600282600581111561090457610904610d15565b0361091257506102ee919050565b600382600581111561092657610926610d15565b0361093457506103e8919050565b600482600581111561094857610948610d15565b0361095657506105dc919050565b600582600581111561096a5761096a610d15565b0361097857506109c4919050565b506000919050565b6000600382600481111561099657610996610d15565b036109a45750611388919050565b60048260048111156109b8576109b8610d15565b036109785750611388919050565b60006109d3826002610d41565b83511015610a1a5760405162461bcd60e51b8152602060048201526014602482015273746f55696e7431365f6f75744f66426f756e647360601b604482015260640161089f565b50818101600201515b92915050565b60606001600160801b03821615610a7157604080516001600160801b0319608086811b8216602084015285901b166030820152016040516020818303038152906040526103a7565b6040516001600160801b0319608085901b1660208201526030016040516020818303038152906040529392505050565b6060836003610ab18260006109c6565b61ffff1614610ac5576108838160006109c6565b846001610ad28551610b0c565b610add906001610d54565b8686604051602001610af3959493929190610d76565b6040516020818303038152906040529150509392505050565b600061ffff821115610b3b576040516306dfcc6560e41b8152601060048201526024810183905260440161089f565b5090565b6001600160a01b0381168114610b5457600080fd5b50565b600060208284031215610b6957600080fd5b81356103a781610b3f565b600080600060608486031215610b8957600080fd5b8335610b9481610b3f565b925060208401359150604084013560ff81168114610bb157600080fd5b809150509250925092565b600060208284031215610bce57600080fd5b81356001600160801b03811681146103a757600080fd5b80518015158114610bf557600080fd5b919050565b600060208284031215610c0c57600080fd5b6103a782610be5565b600060208284031215610c2757600080fd5b81516103a781610b3f565b60005b83811015610c4d578181015183820152602001610c35565b50506000910152565b60008151808452610c6e816020860160208601610c32565b601f01601f19169290920160200192915050565b604081526000610c956040830185610c56565b8281036020840152610ca78185610c56565b95945050505050565b600060208284031215610cc257600080fd5b5051919050565b60008060008060808587031215610cdf57600080fd5b8451935060208501519250604085015160068110610cfc57600080fd5b9150610d0a60608601610be5565b905092959194509250565b634e487b7160e01b600052602160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b80820180821115610a2357610a23610d2b565b61ffff818116838216019080821115610d6f57610d6f610d2b565b5092915050565b60008651610d88818460208b01610c32565b6001600160f81b031960f888811b82169285019283526001600160f01b031960f089901b16600184015286901b1660038201528351610dce816004840160208801610c32565b0160040197965050505050505056fea2646970667358221220088010a0736e1e8a0eec99bad9a6376e52dd476d0ae9599fb0042392ac9f409464736f6c63430008160033",
  "deployedBytecode": "0x60806040526004361061008f5760003560e01c8063caf2976511610056578063caf2976514610197578063e474ad9a146101bb578063f83d08ba146101ee578063f887ea4014610222578063fdfdc29c1461025657005b8063270928ea146100985780637e0cf529146100d5578063ae4df4b4146100f5578063b039492214610143578063c45a01551461016357005b3661009657005b005b3480156100a457600080fd5b506100b86100b3366004610b57565b610276565b6040516001600160a01b0390911681526020015b60405180910390f35b3480156100e157600080fd5b506100966100f0366004610b74565b6103ae565b34801561010157600080fd5b5061012c610110366004610b57565b6001602081905260009182526040909120805491015460ff1682565b6040805192835260ff9091166020830152016100cc565b34801561014f57600080fd5b5061009661015e366004610bbc565b6104b1565b34801561016f57600080fd5b506100b87f000000000000000000000000000000000000000000000000000000000000000081565b3480156101a357600080fd5b506101ad61271081565b6040519081526020016100cc565b3480156101c757600080fd5b506000546101d59060e01b81565b6040516001600160e01b031990911681526020016100cc565b3480156101fa57600080fd5b506100b87f000000000000000000000000000000000000000000000000000000000000000081565b34801561022e57600080fd5b506100b87f000000000000000000000000000000000000000000000000000000000000000081565b34801561026257600080fd5b506101ad610271366004610b57565b61072f565b6000816001600160a01b03163b60000361028e575090565b60405163a26b2a1760e01b81526001600160a01b0383811660048301526000917f00000000000000000000000000000000000000000000000000000000000000009091169063a26b2a1790602401602060405180830381865afa1580156102f9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061031d9190610bfa565b90508061032b575090919050565b6000836001600160a01b0316638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561036b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061038f9190610c15565b90506001600160a01b0381166103a757509192915050565b9392505050565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146103f757604051631eb49d6d60e11b815260040160405180910390fd5b6001600160a01b0383166000908152600160205260409020541561042e5760405163bc63666f60e01b815260040160405180910390fd5b60408051808201825283815260ff83811660208084018281526001600160a01b038916600081815260018085529088902096518755915195909101805460ff19169590941694909417909255925192835284927ff763e680fce25a97ffd55d8b705370c98b47b2285f7b3b2900c43606fd418045910160405180910390a3505050565b3360009081526001602081815260408084208151808301909252805480835293015460ff1691810191909152918190036104fe5760405163dfba2be560e01b815260040160405180910390fd5b6040805180820182526000808252602080830182815233808452600180845286852095518655915194909101805460ff191660ff95861617905586820151855192830191909152938101859052929091166060830152906080016040516020818303038152906040529050600080856001600160801b03161161058f576040805160008152602081019091526105c2565b6105c28560006105bb60408051600360f01b602082015281516002818303018152602290910190915290565b919061085f565b905060007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663cbb02ae984846040518363ffffffff1660e01b8152600401610614929190610c82565b602060405180830381865afa158015610631573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106559190610cb0565b90508047101561067857604051632e626a7160e11b815260040160405180910390fd5b604051630af8b70960e01b81526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690630af8b7099083906106c89087908790600401610c82565b6000604051808303818588803b1580156106e157600080fd5b505af11580156106f5573d6000803e3d6000fd5b50506040518793503392507f884edad9ce6fa2440d8a54cc123490eb96d2768479d49ff9c7366125a94243649150600090a3505050505050565b60008061073b83610276565b604051637238ccdb60e01b81526001600160a01b0380831660048301529192506000917f00000000000000000000000000000000000000000000000000000000000000001690637238ccdb90602401608060405180830381865afa1580156107a7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107cb9190610cc9565b509250505060006107db826108cc565b6001600160a01b03841660009081526001602081815260408084208151808301909252805480835293015460ff169181019190915292935090919080156108405761083d826020015160ff16600481111561083857610838610d15565b610980565b92505b6000838510156108505783610852565b845b9998505050505050505050565b606083600361086f8260006109c6565b61ffff16146108a8576108838160006109c6565b604051633a51740d60e01b815261ffff90911660048201526024015b60405180910390fd5b60006108b48585610a29565b90506108c286600183610aa1565b9695505050505050565b600060018260058111156108e2576108e2610d15565b036108f057506101f4919050565b600282600581111561090457610904610d15565b0361091257506102ee919050565b600382600581111561092657610926610d15565b0361093457506103e8919050565b600482600581111561094857610948610d15565b0361095657506105dc919050565b600582600581111561096a5761096a610d15565b0361097857506109c4919050565b506000919050565b6000600382600481111561099657610996610d15565b036109a45750611388919050565b60048260048111156109b8576109b8610d15565b036109785750611388919050565b60006109d3826002610d41565b83511015610a1a5760405162461bcd60e51b8152602060048201526014602482015273746f55696e7431365f6f75744f66426f756e647360601b604482015260640161089f565b50818101600201515b92915050565b60606001600160801b03821615610a7157604080516001600160801b0319608086811b8216602084015285901b166030820152016040516020818303038152906040526103a7565b6040516001600160801b0319608085901b1660208201526030016040516020818303038152906040529392505050565b6060836003610ab18260006109c6565b61ffff1614610ac5576108838160006109c6565b846001610ad28551610b0c565b610add906001610d54565b8686604051602001610af3959493929190610d76565b6040516020818303038152906040529150509392505050565b600061ffff821115610b3b576040516306dfcc6560e41b8152601060048201526024810183905260440161089f565b5090565b6001600160a01b0381168114610b5457600080fd5b50565b600060208284031215610b6957600080fd5b81356103a781610b3f565b600080600060608486031215610b8957600080fd5b8335610b9481610b3f565b925060208401359150604084013560ff81168114610bb157600080fd5b809150509250925092565b600060208284031215610bce57600080fd5b81356001600160801b03811681146103a757600080fd5b80518015158114610bf557600080fd5b919050565b600060208284031215610c0c57600080fd5b6103a782610be5565b600060208284031215610c2757600080fd5b81516103a781610b3f565b60005b83811015610c4d578181015183820152602001610c35565b50506000910152565b60008151808452610c6e816020860160208601610c32565b601f01601f19169290920160200192915050565b604081526000610c956040830185610c56565b8281036020840152610ca78185610c56565b95945050505050565b600060208284031215610cc257600080fd5b5051919050565b60008060008060808587031215610cdf57600080fd5b8451935060208501519250604085015160068110610cfc57600080fd5b9150610d0a60608601610be5565b905092959194509250565b634e487b7160e01b600052602160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b80820180821115610a2357610a23610d2b565b61ffff818116838216019080821115610d6f57610d6f610d2b565b5092915050565b60008651610d88818460208b01610c32565b6001600160f81b031960f888811b82169285019283526001600160f01b031960f089901b16600184015286901b1660038201528351610dce816004840160208801610c32565b0160040197965050505050505056fea2646970667358221220088010a0736e1e8a0eec99bad9a6376e52dd476d0ae9599fb0042392ac9f409464736f6c63430008160033",
  "devdoc": {
    "author": "3Blocks UG",
    "details": "This contract resolves the effective user address in case the provided wallet is a StrategyVault contract by: - Checking ERC165 supportsInterface for IStrategyVault - Resolving the underlying owner() if applicable The final fee reduction is defined as the maximum of: - The reduction derived from the user's lock tier - The reduction derived from the deposited NFT rarity Fee reductions are expressed in basis points (bps), where 10_000 = 100%. This contract is designed to be read-only for fee logic, except for explicit NFT deposit/withdrawal by users.",
    "errors": {
      "SafeCastOverflowedUintDowncast(uint8,uint256)": [
        {
          "details": "Value doesn't fit in an uint of `bits` size."
        }
      ]
    },
    "events": {
      "Deposit(address,uint256,uint8)": {
        "params": {
          "account": "The user receiving activation",
          "rarity": "The rarity of the deposited NFT",
          "tokenId": "The deposited NFT tokenId"
        }
      },
      "Withdraw(address,uint256)": {
        "params": {
          "account": "The withdrawing user",
          "tokenId": "The withdrawn tokenId"
        }
      }
    },
    "kind": "dev",
    "methods": {
      "_resolveVaultOwner(address)": {
        "details": "If the wallet is an EOA, it is returned directly. If the wallet is a contract, this function attempts to: 1. Detect if it supports the IStrategyVault interface via ERC165. 2. If so, attempt to resolve the underlying owner() address. If any step fails (revert, invalid return data, zero owner), the original wallet address is used as a safe fallback. This ensures robustness against: - Non-compliant contracts - Malicious or reverting implementations - Unexpected ABI behavior",
        "params": {
          "wallet": "The wallet or contract address to resolve."
        },
        "returns": {
          "_0": "resolved The resolved owner or original wallet address."
        }
      },
      "activateTokenForUser(address,uint256,uint8)": {
        "details": "Router-only function, called when an NFT activation message arrives cross-chain Requirements: - Caller must be router - User must not already have an active token Emits {Deposit}",
        "params": {
          "rarity": "The rarity classification of the NFT",
          "tokenId": "The activated NFT tokenId",
          "user": "The user receiving the activation"
        }
      },
      "getFeeReduction(address)": {
        "details": "If the wallet is a StrategyVault, the underlying owner is resolved and used for fee calculation. The returned reduction is the maximum of: - Lock-tier based fee reduction - NFT-rarity based fee reduction If neither applies, returns 0.",
        "params": {
          "wallet": "The wallet or StrategyVault address to query."
        },
        "returns": {
          "_0": "reduction The fee reduction in basis points (bps)."
        }
      },
      "withdrawToken(uint128)": {
        "details": "Resets the user's deposited token state and transfers the token back to the user. Requirements: - The caller must have a token deposited. Emits a {Withdraw} event."
      }
    },
    "stateVariables": {
      "lock": {
        "details": "Used to resolve the user's lock tier for fee reduction."
      },
      "userTokenInfos": {
        "details": "Each user may deposit at most one NFT at a time. A value of 0 indicates no NFT deposited."
      }
    },
    "title": "FeeReduction",
    "version": 1
  },
  "userdoc": {
    "errors": {
      "AlreadyTokenActive()": [
        {
          "notice": "User already has an active deposited token"
        }
      ],
      "NoTokenActive()": [
        {
          "notice": "User has no active token deposited"
        }
      ],
      "NotAllowed()": [
        {
          "notice": "Caller is not allowed (router-only)"
        }
      ],
      "OutOfFunds()": [
        {
          "notice": "Contract has insufficient native funds to send cross-chain message"
        }
      ]
    },
    "events": {
      "Deposit(address,uint256,uint8)": {
        "notice": "Emitted when a token is deposited for a user"
      },
      "Withdraw(address,uint256)": {
        "notice": "Emitted when a user withdraws their deposited token"
      }
    },
    "kind": "user",
    "methods": {
      "PERCENTAGE_DIVISOR()": {
        "notice": "Divisor for percentage calculations (10000 = 100%)."
      },
      "_resolveVaultOwner(address)": {
        "notice": "Resolves the effective user address for fee calculations."
      },
      "activateTokenForUser(address,uint256,uint8)": {
        "notice": "Deposits a token activation for a user"
      },
      "getFeeReduction(address)": {
        "notice": "Returns the effective fee reduction for a given wallet."
      },
      "lock()": {
        "notice": "Address of the Tiered Token Locker contract."
      },
      "router()": {
        "notice": "Returns the router allowed to deposit tokens"
      },
      "userTokenInfos(address)": {
        "notice": "Mapping of user address to deposited NFT tokenId."
      },
      "withdrawToken(uint128)": {
        "notice": "Withdraws the previously deposited token."
      }
    },
    "notice": "Provides a unified fee reduction mechanism based on: 1) Token lock tiers 2) Deposited NFT rarity",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 3643,
        "contract": "contracts/StrategyBuilderFeeReduction.sol:StrategyBuilderFeeReduction",
        "label": "strategyVaultInterfaceId",
        "offset": 0,
        "slot": "0",
        "type": "t_bytes4"
      },
      {
        "astId": 3649,
        "contract": "contracts/StrategyBuilderFeeReduction.sol:StrategyBuilderFeeReduction",
        "label": "userTokenInfos",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_struct(TokenInfo)4088_storage)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bytes4": {
        "encoding": "inplace",
        "label": "bytes4",
        "numberOfBytes": "4"
      },
      "t_mapping(t_address,t_struct(TokenInfo)4088_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct IStrategyBuilderFeeReduction.TokenInfo)",
        "numberOfBytes": "32",
        "value": "t_struct(TokenInfo)4088_storage"
      },
      "t_struct(TokenInfo)4088_storage": {
        "encoding": "inplace",
        "label": "struct IStrategyBuilderFeeReduction.TokenInfo",
        "members": [
          {
            "astId": 4085,
            "contract": "contracts/StrategyBuilderFeeReduction.sol:StrategyBuilderFeeReduction",
            "label": "tokenId",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 4087,
            "contract": "contracts/StrategyBuilderFeeReduction.sol:StrategyBuilderFeeReduction",
            "label": "rarity",
            "offset": 0,
            "slot": "1",
            "type": "t_uint8"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}